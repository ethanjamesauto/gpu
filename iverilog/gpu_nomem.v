/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_D_FF_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input [(Bits-1):0] D,
   input C,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



// hex synchronous counter
module \74163  (
  input \~PE ,
  input \~SR ,
  input CP,
  input CET,
  input CEP,
  input P0,
  input P1,
  input P2,
  input P3,
  input VCC,
  input GND,
  output TC,
  output Q0,
  output Q1,
  output Q2,
  output Q3
);
  wire [3:0] s0;
  wire [3:0] s1;
  wire [3:0] s2;
  wire s3;
  wire s4;
  wire [3:0] s5;
  wire [3:0] s6;
  wire [3:0] s7;
  assign s4 = (CEP & CET);
  assign s6[0] = P0;
  assign s6[1] = P1;
  assign s6[2] = P2;
  assign s6[3] = P3;
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( s4 ),
    .in_0( s1 ),
    .in_1( s2 ),
    .out( s5 )
  );
  assign TC = (s3 & CET);
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i1 (
    .sel( \~PE  ),
    .in_0( s6 ),
    .in_1( s5 ),
    .out( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i2 (
    .sel( \~SR  ),
    .in_0( 4'b0 ),
    .in_1( s7 ),
    .out( s0 )
  );
  // Q
  DIG_D_FF_Nbit #(
    .Bits(4),
    .Default(0)
  )
  DIG_D_FF_Nbit_i3 (
    .D( s0 ),
    .C( CP ),
    .Q( s1 )
  );
  DIG_Add #(
    .Bits(4)
  )
  DIG_Add_i4 (
    .a( s1 ),
    .b( 4'b1 ),
    .c_i( 1'b0 ),
    .s( s2 ),
    .c_o( s3 )
  );
  assign Q0 = s1[0];
  assign Q1 = s1[1];
  assign Q2 = s1[2];
  assign Q3 = s1[3];
endmodule

module memory_ptr (
  input [7:0] in0,
  input en,
  input \~ld0 ,
  input [7:0] in1,
  input clk,
  input \~ld1 ,
  output [15:0] out
);
  wire [3:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire [3:0] s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire [3:0] s24;
  wire [3:0] s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire s30;
  wire s31;
  wire s32;
  wire s33;
  wire [3:0] s34;
  wire [3:0] s35;
  wire s36;
  wire s37;
  wire s38;
  wire s39;
  wire s40;
  wire s41;
  wire s42;
  assign s0 = in0[3:0];
  assign s10 = in0[7:4];
  assign s25 = in1[3:0];
  assign s35 = in1[7:4];
  assign s1 = s0[0];
  assign s2 = s0[1];
  assign s3 = s0[2];
  assign s4 = s0[3];
  assign s11 = s10[0];
  assign s12 = s10[1];
  assign s13 = s10[2];
  assign s14 = s10[3];
  assign s26 = s25[0];
  assign s27 = s25[1];
  assign s28 = s25[2];
  assign s29 = s25[3];
  assign s36 = s35[0];
  assign s37 = s35[1];
  assign s38 = s35[2];
  assign s39 = s35[3];
  \74163  \74163_i0 (
    .\~SR ( 1'b1 ),
    .CP( clk ),
    .P0( s1 ),
    .P1( s2 ),
    .P2( s3 ),
    .P3( s4 ),
    .CEP( en ),
    .GND( 1'b0 ),
    .\~PE ( \~ld0  ),
    .CET( 1'b1 ),
    .VCC( 1'b1 ),
    .Q3( s8 ),
    .Q2( s7 ),
    .Q1( s6 ),
    .Q0( s5 ),
    .TC( s40 )
  );
  assign s9[0] = s5;
  assign s9[1] = s6;
  assign s9[2] = s7;
  assign s9[3] = s8;
  \74163  \74163_i1 (
    .\~SR ( 1'b1 ),
    .CP( clk ),
    .P0( s11 ),
    .P1( s12 ),
    .P2( s13 ),
    .P3( s14 ),
    .CEP( en ),
    .GND( 1'b0 ),
    .\~PE ( \~ld0  ),
    .CET( s40 ),
    .VCC( 1'b1 ),
    .Q3( s18 ),
    .Q2( s17 ),
    .Q1( s16 ),
    .Q0( s15 ),
    .TC( s41 )
  );
  assign s19[0] = s15;
  assign s19[1] = s16;
  assign s19[2] = s17;
  assign s19[3] = s18;
  \74163  \74163_i2 (
    .\~SR ( 1'b1 ),
    .CP( clk ),
    .P0( s26 ),
    .P1( s27 ),
    .P2( s28 ),
    .P3( s29 ),
    .CEP( en ),
    .GND( 1'b0 ),
    .\~PE ( \~ld1  ),
    .CET( s41 ),
    .VCC( 1'b1 ),
    .Q3( s23 ),
    .Q2( s22 ),
    .Q1( s21 ),
    .Q0( s20 ),
    .TC( s42 )
  );
  assign s24[0] = s20;
  assign s24[1] = s21;
  assign s24[2] = s22;
  assign s24[3] = s23;
  \74163  \74163_i3 (
    .\~SR ( 1'b1 ),
    .CP( clk ),
    .P0( s36 ),
    .P1( s37 ),
    .P2( s38 ),
    .P3( s39 ),
    .CEP( en ),
    .GND( 1'b0 ),
    .\~PE ( \~ld1  ),
    .CET( s42 ),
    .VCC( 1'b1 ),
    .Q3( s33 ),
    .Q2( s32 ),
    .Q1( s31 ),
    .Q0( s30 )
  );
  assign s34[0] = s30;
  assign s34[1] = s31;
  assign s34[2] = s32;
  assign s34[3] = s33;
  assign out[3:0] = s9;
  assign out[7:4] = s19;
  assign out[11:8] = s24;
  assign out[15:12] = s34;
endmodule
module DIG_JK_FF
#(
    parameter Default = 1'b0
)
(
   input J,
   input C,
   input K,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        if (~J & K)
            state <= 1'b0;
         else if (J & ~K)
            state <= 1'b1;
         else if (J & K)
            state <= ~state;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

// octal D-type flip-flop with clear
module \74273  (
  input CP,
  input \~MR ,
  input D0,
  input D1,
  input D2,
  input D3,
  input D4,
  input D5,
  input D6,
  input D7,
  input VCC,
  input GND,
  output Q0,
  output Q1,
  output Q2,
  output Q3,
  output Q4,
  output Q5,
  output Q6,
  output Q7
);
  wire s0;
  assign s0 = ~ \~MR ;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i0 (
    .Set( 1'b0 ),
    .D( D1 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q1 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( D2 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q2 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( D3 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q3 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( D0 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q0 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( 1'b0 ),
    .D( D4 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q4 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i5 (
    .Set( 1'b0 ),
    .D( D5 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q5 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i6 (
    .Set( 1'b0 ),
    .D( D6 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q6 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i7 (
    .Set( 1'b0 ),
    .D( D7 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q7 )
  );
endmodule

module \8bit_register  (
  input clk,
  input [7:0] D,
  input en,
  output [7:0] Q
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  assign s8 = (en & clk);
  assign s1 = D[0];
  assign s2 = D[1];
  assign s5 = D[2];
  assign s6 = D[3];
  assign s10 = D[4];
  assign s11 = D[5];
  assign s14 = D[6];
  assign s15 = D[7];
  \74273  \74273_i0 (
    .\~MR ( 1'b1 ),
    .D0( s1 ),
    .D1( s2 ),
    .D2( s5 ),
    .D3( s6 ),
    .GND( 1'b0 ),
    .CP( s8 ),
    .D4( s10 ),
    .D5( s11 ),
    .D6( s14 ),
    .D7( s15 ),
    .VCC( 1'b1 ),
    .Q0( s0 ),
    .Q1( s3 ),
    .Q2( s4 ),
    .Q3( s7 ),
    .Q4( s9 ),
    .Q5( s12 ),
    .Q6( s13 ),
    .Q7( s16 )
  );
  assign Q[0] = s0;
  assign Q[1] = s3;
  assign Q[2] = s4;
  assign Q[3] = s7;
  assign Q[4] = s9;
  assign Q[5] = s12;
  assign Q[6] = s13;
  assign Q[7] = s16;
endmodule

module \8bit_counter  (
  input [7:0] in,
  input en,
  input \~ld ,
  input clk,
  output [7:0] out,
  output ovf
);
  wire [3:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire [3:0] s19;
  wire s20;
  assign s0 = in[3:0];
  assign s10 = in[7:4];
  assign s1 = s0[0];
  assign s2 = s0[1];
  assign s3 = s0[2];
  assign s4 = s0[3];
  assign s11 = s10[0];
  assign s12 = s10[1];
  assign s13 = s10[2];
  assign s14 = s10[3];
  \74163  \74163_i0 (
    .\~SR ( 1'b1 ),
    .CP( clk ),
    .P0( s1 ),
    .P1( s2 ),
    .P2( s3 ),
    .P3( s4 ),
    .CEP( en ),
    .GND( 1'b0 ),
    .\~PE ( \~ld  ),
    .CET( 1'b1 ),
    .VCC( 1'b1 ),
    .Q3( s8 ),
    .Q2( s7 ),
    .Q1( s6 ),
    .Q0( s5 ),
    .TC( s20 )
  );
  assign s9[0] = s5;
  assign s9[1] = s6;
  assign s9[2] = s7;
  assign s9[3] = s8;
  \74163  \74163_i1 (
    .\~SR ( 1'b1 ),
    .CP( clk ),
    .P0( s11 ),
    .P1( s12 ),
    .P2( s13 ),
    .P3( s14 ),
    .CEP( en ),
    .GND( 1'b0 ),
    .\~PE ( \~ld  ),
    .CET( s20 ),
    .VCC( 1'b1 ),
    .Q3( s18 ),
    .Q2( s17 ),
    .Q1( s16 ),
    .Q0( s15 ),
    .TC( ovf )
  );
  assign s19[0] = s15;
  assign s19[1] = s16;
  assign s19[2] = s17;
  assign s19[3] = s18;
  assign out[3:0] = s9;
  assign out[7:4] = s19;
endmodule

module state_char (
  input [7:0] D,
  input drawing,
  input clk,
  input reset,
  input en,
  output next,
  output done,
  output send,
  output fill
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  assign s3 = (~ D[0] & en);
  assign s0 = D[3];
  assign fill = (s3 & ~ s0);
  assign s1 = (s3 & s0);
  assign next = (s1 & D[1]);
  assign done = (s1 & D[2]);
  assign s2 = (s1 & D[4] & drawing);
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i0 (
    .J( s2 ),
    .C( clk ),
    .K( reset ),
    .Q( send )
  );
endmodule

module sprite_ptr (
  input en0,
  input clk,
  input \~clr0 ,
  input \~clr1 ,
  input en1,
  output [15:0] out
);
  wire [3:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire [3:0] s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire [3:0] s24;
  wire [3:0] s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire s30;
  wire s31;
  wire s32;
  wire s33;
  wire [3:0] s34;
  wire [3:0] s35;
  wire s36;
  wire s37;
  wire s38;
  wire s39;
  wire [7:0] const8b0;
  wire s40;
  wire s41;
  wire s42;
  assign const8b0 = 8'b0;
  assign s25 = const8b0[3:0];
  assign s35 = const8b0[7:4];
  assign s26 = s25[0];
  assign s27 = s25[1];
  assign s28 = s25[2];
  assign s29 = s25[3];
  assign s36 = s35[0];
  assign s37 = s35[1];
  assign s38 = s35[2];
  assign s39 = s35[3];
  \74163  \74163_i0 (
    .\~SR ( \~clr0  ),
    .CP( clk ),
    .P0( s1 ),
    .P1( s2 ),
    .P2( s3 ),
    .P3( s4 ),
    .CEP( en0 ),
    .GND( 1'b0 ),
    .\~PE ( 1'b1 ),
    .CET( 1'b1 ),
    .VCC( 1'b1 ),
    .Q3( s8 ),
    .Q2( s7 ),
    .Q1( s6 ),
    .Q0( s5 ),
    .TC( s40 )
  );
  \74163  \74163_i1 (
    .\~SR ( \~clr1  ),
    .CP( clk ),
    .P0( s11 ),
    .P1( s12 ),
    .P2( s13 ),
    .P3( s14 ),
    .CEP( en1 ),
    .GND( 1'b0 ),
    .\~PE ( 1'b1 ),
    .CET( s40 ),
    .VCC( 1'b1 ),
    .Q3( s18 ),
    .Q2( s17 ),
    .Q1( s16 ),
    .Q0( s15 ),
    .TC( s41 )
  );
  \74163  \74163_i2 (
    .\~SR ( \~clr1  ),
    .CP( clk ),
    .P0( s26 ),
    .P1( s27 ),
    .P2( s28 ),
    .P3( s29 ),
    .CEP( en1 ),
    .GND( 1'b0 ),
    .\~PE ( 1'b1 ),
    .CET( s41 ),
    .VCC( 1'b1 ),
    .Q3( s23 ),
    .Q2( s22 ),
    .Q1( s21 ),
    .Q0( s20 ),
    .TC( s42 )
  );
  \74163  \74163_i3 (
    .\~SR ( \~clr1  ),
    .CP( clk ),
    .P0( s36 ),
    .P1( s37 ),
    .P2( s38 ),
    .P3( s39 ),
    .CEP( en1 ),
    .GND( 1'b0 ),
    .\~PE ( 1'b1 ),
    .CET( s42 ),
    .VCC( 1'b1 ),
    .Q3( s33 ),
    .Q2( s32 ),
    .Q1( s31 ),
    .Q0( s30 )
  );
  assign s9[0] = s5;
  assign s9[1] = s6;
  assign s9[2] = s7;
  assign s9[3] = s8;
  assign s19[0] = s15;
  assign s19[1] = s16;
  assign s19[2] = s17;
  assign s19[3] = s18;
  assign s24[0] = s20;
  assign s24[1] = s21;
  assign s24[2] = s22;
  assign s24[3] = s23;
  assign s34[0] = s30;
  assign s34[1] = s31;
  assign s34[2] = s32;
  assign s34[3] = s33;
  assign out[3:0] = s9;
  assign out[7:4] = s19;
  assign out[11:8] = s24;
  assign out[15:12] = s34;
  assign s1 = s0[0];
  assign s2 = s0[1];
  assign s3 = s0[2];
  assign s4 = s0[3];
  assign s11 = s10[0];
  assign s12 = s10[1];
  assign s13 = s10[2];
  assign s14 = s10[3];
  assign s0 = 4'b0;
  assign s10 = 4'b0;
endmodule

module Demux3
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel,
    input in
);
    assign out_0 = (sel == 3'h0)? in : 'd0;
    assign out_1 = (sel == 3'h1)? in : 'd0;
    assign out_2 = (sel == 3'h2)? in : 'd0;
    assign out_3 = (sel == 3'h3)? in : 'd0;
    assign out_4 = (sel == 3'h4)? in : 'd0;
    assign out_5 = (sel == 3'h5)? in : 'd0;
    assign out_6 = (sel == 3'h6)? in : 'd0;
    assign out_7 = (sel == 3'h7)? in : 'd0;
endmodule


// 3-line to 8-line decoder/demultiplexer, inverted out
module \74138_modified  (
  input A,
  input C,
  input B,
  input G,
  input \~GB ,
  input \~GA ,
  input VCC,
  input GND,
  output \~Y0 ,
  output \~Y1 ,
  output \~Y2 ,
  output \~Y3 ,
  output \~Y4 ,
  output \~Y5 ,
  output \~Y6 ,
  output \~Y7 
);
  wire [2:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  assign s0[0] = A;
  assign s0[1] = B;
  assign s0[2] = C;
  assign s9 = (G & ~ \~GB  & ~ \~GA );
  Demux3 Demux3_i0 (
    .sel( s0 ),
    .in( s9 ),
    .out_0( s1 ),
    .out_1( s2 ),
    .out_2( s3 ),
    .out_3( s4 ),
    .out_4( s5 ),
    .out_5( s6 ),
    .out_6( s7 ),
    .out_7( s8 )
  );
  assign \~Y0  = ~ s1;
  assign \~Y1  = ~ s2;
  assign \~Y2  = ~ s3;
  assign \~Y3  = ~ s4;
  assign \~Y4  = ~ s5;
  assign \~Y5  = ~ s6;
  assign \~Y6  = ~ s7;
  assign \~Y7  = ~ s8;
endmodule

module gpu_nomem (
  input clk,
  input [15:0] addr_in,
  input start,
  input [7:0] data,
  output [15:0] addr_ram,
  output [15:0] addr_rom,
  output store_ram,
  output load_ram,
  output load_rom
);
  wire [15:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire [7:0] s7;
  wire [7:0] s8;
  wire [1:0] s9;
  wire [15:0] s10;
  wire drawing;
  wire s11;
  wire s12;
  wire done;
  wire reset;
  wire s13;
  wire load_5;
  wire load_4;
  wire s14;
  wire \~idling ;
  wire s15;
  wire [7:0] s16;
  wire s17;
  wire s18;
  wire s19;
  wire load_3;
  wire s20;
  wire load_rom_temp;
  wire s21;
  wire load_ram_temp;
  wire fill;
  wire data_0;
  wire s22;
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i0 (
    .sel( s9 ),
    .in_0( s10 ),
    .in_1( s0 ),
    .in_2( addr_in ),
    .in_3( addr_in ),
    .out( addr_rom )
  );
  memory_ptr memory_ptr_i1 (
    .in0( data ),
    .en( s13 ),
    .\~ld0 ( load_5 ),
    .in1( data ),
    .clk( clk ),
    .\~ld1 ( load_4 ),
    .out( s10 )
  );
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i2 (
    .J( s15 ),
    .C( clk ),
    .K( start ),
    .Q( s12 ),
    .\~Q ( \~idling  )
  );
  \8bit_register  \8bit_register_i3 (
    .clk( clk ),
    .D( data ),
    .en( s5 ),
    .Q( s16 )
  );
  \8bit_counter  \8bit_counter_i4 (
    .in( data ),
    .en( s19 ),
    .\~ld ( load_3 ),
    .clk( clk ),
    .out( s8 ),
    .ovf( s20 )
  );
  state_char state_char_i5 (
    .D( data ),
    .drawing( drawing ),
    .clk( clk ),
    .reset( reset ),
    .en( load_rom_temp ),
    .next( s21 ),
    .done( done ),
    .send( load_ram_temp ),
    .fill( fill )
  );
  assign data_0 = (data[0] & load_rom_temp);
  assign s13 = ~ fill;
  assign load_rom_temp = (~ load_ram_temp & \~idling );
  assign addr_ram[7:0] = s7;
  assign addr_ram[15:8] = s8;
  assign store_ram = (drawing & (fill | data_0));
  assign s9[0] = s11;
  assign s9[1] = s12;
  assign reset = ((s20 & s18) | done);
  sprite_ptr sprite_ptr_i6 (
    .en0( s14 ),
    .clk( clk ),
    .\~clr0 ( \~idling  ),
    .\~clr1 ( \~idling  ),
    .en1( s14 ),
    .out( s0 )
  );
  \8bit_counter  \8bit_counter_i7 (
    .in( s16 ),
    .en( drawing ),
    .\~ld ( s17 ),
    .clk( clk ),
    .out( s7 ),
    .ovf( s18 )
  );
  assign s19 = (s21 | s18 | ~ s6);
  assign s15 = (data_0 & ~ s22);
  assign s17 = ~ s19;
  assign s1 = s0[0];
  assign s2 = s0[1];
  assign s3 = s0[2];
  \74138_modified  \74138_modified_i8 (
    .A( s1 ),
    .B( s2 ),
    .C( s3 ),
    .\~GA ( 1'b0 ),
    .\~GB ( 1'b0 ),
    .G( 1'b1 ),
    .GND( 1'b0 ),
    .VCC( 1'b1 ),
    .\~Y7 ( s11 ),
    .\~Y5 ( load_5 ),
    .\~Y4 ( load_4 ),
    .\~Y3 ( load_3 ),
    .\~Y2 ( s6 ),
    .\~Y1 ( s4 ),
    .\~Y0 ( s22 )
  );
  assign s5 = ~ s4;
  assign s14 = (reset | s11);
  assign drawing = ~ s11;
  assign load_ram = load_ram_temp;
  assign load_rom = load_rom_temp;
endmodule
